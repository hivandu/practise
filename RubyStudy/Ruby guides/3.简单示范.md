來寫個函式計算階乘吧。n 階乘的數學定義是：

n! = 1                （當 n==0）
   = n * (n-1)!       （否則）

這可在 Ruby 中寫成：

    def fact(n)
      if n == 0
        1
      else
        n * fact(n-1)
      end
    end

你會發現 end 重複出現， Ruby 正是因此而稱為類似「算法」(Algol) 的語言。（其實，Ruby 的語法更接近 Eiffel 語言。）你也會發現並沒有 return 敘述， 因為 Ruby 函數會回傳最後計算的步驟。Ruby 可以使用 return 敘述，但並不必要。

來試試我們的階乘函式吧。再加入一行程式碼就能運作這個程式：

    # 計算出數字的階乘
    # 請把程式儲存為 fact.rb

    def fact(n)
      if n == 0
        1
      else
        n * fact(n-1)
      end
    end

    puts fact(ARGV[0].to_i)


上面的 ARGV 是一個陣列，其中包含了命令列引數 (command line arguments)，而 to_i 將字元字串 (character string) 轉換為整數。

    % ruby fact.rb 1
    1
    % ruby fact.rb 5
    120

能不能計算引數為 40 呢？這會讓你的計算機溢位 (overflow)……

    % ruby fact.rb 40
    815915283247897734345611269596115894272000000000

確實能夠運算， 其實只要電腦的記憶體足夠，Ruby 能夠處理任何整數。所以就算是 400 也能夠計算：

    % ruby fact.rb 400
    64034522846623895262347970319503005850702583026002959458684
    44594280239716918683143627847864746326467629435057503585681
    08482981628835174352289619886468029979373416541508381624264
    61942352307046244325015114448670890662773914918117331955996
    44070954967134529047702032243491121079759328079510154537266
    72516278778900093497637657103263503315339653498683868313393
    52024373788157786791506311858702618270169819740062983025308
    59129834616227230455833952075961150530223608681043329725519
    48526744322324386699484224042325998055516106359423769613992 
    31917134063858996537970147827206606320217379472010321356624 
    61380907794230459736069956759583609615871512991382228657857 
    95493616176544804532220078258184008484364155912294542753848 
    03558374518022675900061399560145595206127211192918105032491 
    00800000000000000000000000000000000000000000000000000000000 
    0000000000000000000000000000000000000000000

我們不可能一眼就看出對錯，但結果一定是對的。:-)

#### 互動模式

執行 Ruby 而未輸入引數，Ruby 會從標準輸入 (standard input) 讀取指令，在輸入結束後開始執行：

    % ruby
    puts "hello world"
    puts "good-bye world"
    ^D
    hello world
    good-bye world

上面的 ^D 表示 control-D，可以方便地在 Unix 環境中表示輸入結束。在 DOS/Windows 中，可以按 F6 或 ^Z。

Ruby 同時具有 eval.rb 程式，可以利用鍵盤在互動式迴圈 (interactive loop) 中輸入 Ruby 程式碼，隨即就能顯示結果。這在本手冊中將經常使用。（編註：您可以使用 irb 指令直接進入此互動模式）

若你使用 ANSI 相容的終端機 (terminal)（如果是使用 UNIX 系統，那幾乎都是 ANSI 相容的終端機；有些舊版本的 DOS，需要安裝 ANSI.SYS 或 ANSI.COM；不幸的是，Windows XP 現在幾乎無法使用），就應該使用加強版 eval.rb，提供視覺縮排協助 (visual indenting assistance)、提示報告、顏色強調。不然的話，在可用於任何終端機的非 ANSI 版中，到 sample 子目錄中。這是一小段 eval.rb：

    % ruby eval.rb （編註：您也可以直接輸入 irb 指令直接進入此互動模式）
    ruby> puts "Hello, world."
    Hello, world.
       nil
    ruby> exit
    
hello world 由 puts 產生。下一行（即 nil）報告任何最後計算的結果；Ruby 不會區分 敘述 (statements) 與 表示式 (expressions)，所以計算程式碼也就是執行程式碼。這個例子中，nil 表示 puts 並無傳回任何有意義的值。請注意，我們可以輸入 exit 或利用 ^D 離開這個直譯器回圈。

本手冊中，"ruby>" 代表 eval.rb （編註：或 irb）這個實用小程式的輸入提示符。